import os
import requests
import time
import logging
from typing import List, Dict

# 配置日志
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

class AccountKeeper:
    def __init__(self):
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
        })
    
    def extract_accounts_from_variables(self) -> List[Dict[str, str]]:
        """
        从环境变量中提取所有账号信息
        变量格式：ACCOUNT1_EMAIL, ACCOUNT1_PASSWORD, ACCOUNT2_EMAIL, ACCOUNT2_PASSWORD, 等等
        """
        accounts = []
        i = 1
        
        while True:
            email_var = f"ACCOUNT{i}_EMAIL"
            password_var = f"ACCOUNT{i}_PASSWORD"
            
            email = os.getenv(email_var)
            password = os.getenv(password_var)
            
            # 如果找不到对应序号的变量，停止搜索
            if not email or not password:
                if i == 1:
                    logger.warning("未找到账号信息，请检查环境变量设置")
                break
            
            accounts.append({
                'email': email,
                'password': password,
                'account_id': i
            })
            logger.info(f"成功加载账号 {i}: {email}")
            i += 1
        
        return accounts
    
    def login(self, email: str, password: str) -> bool:
        """
        模拟登录操作
        这里需要根据实际网站的登录接口进行修改
        """
        try:
            # 示例登录请求 - 需要根据实际网站修改
            login_data = {
                'email': email,
                'password': password,
                'remember_me': True
            }
            
            # 这里替换为实际的登录URL
            response = self.session.post('https://example.com/api/login', json=login_data)
            
            if response.status_code == 200:
                logger.info(f"登录成功: {email}")
                return True
            else:
                logger.error(f"登录失败 {email}: HTTP {response.status_code}")
                return False
                
        except Exception as e:
            logger.error(f"登录异常 {email}: {str(e)}")
            return False
    
    def keep_alive(self, account: Dict[str, str]) -> bool:
        """
        保活操作 - 模拟用户活动
        """
        try:
            # 示例保活操作 - 需要根据实际需求修改
            activities = [
                self.check_notifications,
                self.refresh_profile,
                self.make_dummy_request
            ]
            
            success_count = 0
            for activity in activities:
                if activity(account):
                    success_count += 1
                time.sleep(2)  # 间隔2秒执行下一个操作
            
            return success_count > 0
            
        except Exception as e:
            logger.error(f"保活操作异常 {account['email']}: {str(e)}")
            return False
    
    def check_notifications(self, account: Dict[str, str]) -> bool:
        """
        检查通知 - 示例保活操作1
        """
        try:
            response = self.session.get('https://example.com/api/notifications')
            return response.status_code == 200
        except:
            return False
    
    def refresh_profile(self, account: Dict[str, str]) -> bool:
        """
        刷新个人资料 - 示例保活操作2
        """
        try:
            response = self.session.get('https://example.com/api/profile')
            return response.status_code == 200
        except:
            return False
    
    def make_dummy_request(self, account: Dict[str, str]) -> bool:
        """
        发送虚拟请求 - 示例保活操作3
        """
        try:
            response = self.session.get('https://example.com/api/ping')
            return response.status_code == 200
        except:
            return False
    
    def logout(self, account: Dict[str, str]):
        """
        登出操作（可选）
        """
        try:
            self.session.post('https://example.com/api/logout')
            logger.info(f"已登出: {account['email']}")
        except Exception as e:
            logger.error(f"登出异常 {account['email']}: {str(e)}")
    
    def run_keep_alive_for_account(self, account: Dict[str, str]):
        """
        为单个账号执行保活流程
        """
        logger.info(f"开始处理账号 {account['account_id']}: {account['email']}")
        
        # 登录
        if self.login(account['email'], account['password']):
            # 执行保活操作
            if self.keep_alive(account):
                logger.info(f"账号 {account['email']} 保活成功")
            else:
                logger.warning(f"账号 {account['email']} 保活操作部分失败")
            
            # 可选：登出
            # self.logout(account)
        else:
            logger.error(f"账号 {account['email']} 登录失败，跳过保活")
    
    def run(self, interval_minutes: int = 60):
        """
        主循环，定期为所有账号执行保活
        """
        logger.info("开始多账号保活服务")
        
        while True:
            try:
                # 每次循环都重新获取账号信息（支持动态更新）
                accounts = self.extract_accounts_from_variables()
                
                if not accounts:
                    logger.warning("未找到任何账号信息，等待下次循环")
                    time.sleep(interval_minutes * 60)
                    continue
                
                logger.info(f"本轮处理 {len(accounts)} 个账号")
                
                # 为每个账号执行保活
                for account in accounts:
                    try:
                        self.run_keep_alive_for_account(account)
                        
                        # 账号间间隔
                        time.sleep(5)
                        
                    except Exception as e:
                        logger.error(f"处理账号 {account['email']} 时发生异常: {str(e)}")
                        continue
                
                logger.info(f"本轮保活完成，等待 {interval_minutes} 分钟后继续")
                time.sleep(interval_minutes * 60)
                
            except KeyboardInterrupt:
                logger.info("收到中断信号，停止服务")
                break
            except Exception as e:
                logger.error(f"主循环发生异常: {str(e)}")
                time.sleep(60)  # 异常后等待1分钟再继续

def main():
    """主函数"""
    keeper = AccountKeeper()
    
    # 设置保活间隔（分钟）
    interval = int(os.getenv('KEEP_ALIVE_INTERVAL', '60'))
    
    try:
        keeper.run(interval_minutes=interval)
    except Exception as e:
        logger.error(f"服务运行异常: {str(e)}")

if __name__ == "__main__":
    main()
